%matplotlib inline
from scipy.special import ellipk, ellipe, ellipkm1
from numpy import pi, sqrt, linspace
from pylab import plot, xlabel, ylabel, suptitle, legend, show
import numpy as np
n=10
d=12.5*10**-3
uo =n* 4E-3*pi     # Permeability constant - units of H/m
Bo = lambda i, a, u=uo: i*u/2./a    # Central field = f(current, loop radius, perm. constant)
al = lambda r, a: r/a               # Alpha = f(radius of measurement point, radius of loop)
be = lambda x, a: x/a               # Beta = f(axial distance to meas. point, radius of loop)
ga = lambda x, r: x/r               # Gamma = f(axial distance, radius to meas. point)
Q = lambda r, x, a: (1 + al(r,a))**2 + be(x,a)**2   # Q = f(radius, distance to meas. point, loop radius)
k = lambda r, x, a: sqrt(4*al(r,a)/Q(r,x,a))       # k = f(radius, distance to meas. point, loop radius)
K = lambda k: ellipk(k**2.0)          # Elliptic integral, first kind, as a function of k
E = lambda k: ellipe(k**2.0)          # Elliptic integral, second kind, as a function of k
# On-Axis field = f(current and radius of loop, x of measurement point)
def Baxial(i, a, x, u=uo):
    if a == 0:
        if x == 0:
            return NaN
        else:
            return 0.0
    else:
        return (u*i*a**2)/2.0/(a**2 + x**2)**(1.5)

# Axial field component = f(current and radius of loop, r and x of meas. point)
def Bx(i, a, x, r):
    if r == 0:
        if x == 0:
            return Bo(i,a)         
        else:
            return Baxial(i,a,x)   
    else:                         
        return Bo(i,a)*\
            (E(k(r,x,a))*((1.0-al(r,a)**2-be(x,a)**2)/(Q(r,x,a)-4*al(r,a))) + K(k(r,x,a)))\
            /pi/sqrt(Q(r,x,a))
        
# Radial field component = f(current and radius of loop, r and x of meas. point)
def Br(i, a, x, r):
    if r == 0:
        return 0                  
    else:                          
        return Bo(i,a)*ga(x,r)*\
            (E(k(r,x,a))*((1.0+al(r,a)**2+be(x,a)**2)/(Q(r,x,a)-4*al(r,a))) - K(k(r,x,a)))\
            /pi/sqrt(Q(r,x,a))
def btotax(i,a,x,u=uo):
    return Baxial(i, a, x-a/2, u=uo)+Baxial(i, a, x+a/2, u=uo)
def btotx(i, a, x, r):
    return Bx(i, a, x-a/2, r)+Bx(i, a, x+a/2, r)
def brtot(i, a, x, r):
    return Br(i, a, x-a/2, r)+Br(i, a, x+a/2, r)
def brtot_cartesian(i, a, x, y, z):
    r = np.sqrt(x**2 + y**2 + z**2)  
    
    # Calculate the radial and axial field components
    br = brtot(i, a, x, r)   
    bx = btotx(i, a, x, r)  

    # Convert to Cartesian coordinates using x, y, and r
    bxcar = bx       
    bycar = br * y / r       
    bzcar = br * z / r               

    return bxcar, bycar, bzcar
import numpy as np
import matplotlib.pyplot as plt

# Constants
i = 6.8   # Current in Amps
a = 0.025  # Loop radius in meters (25 mm)

# Create grid for y and z values (since we are considering the zy-plane)
y_vals = np.linspace(-0.030, 0.030, 100)  # y range from -30 to 30
z_vals = np.linspace(-0.030, 0.030, 100)  # z range from -30 to 30

# Create meshgrid for the coordinates (we set x = 0 for the zy-plane)
Y, Z = np.meshgrid(y_vals, z_vals)

# Calculate the radial distance from the origin
r_vals = np.sqrt(Y**2 + Z**2)

# Compute the magnetic field components in Cartesian coordinates in the zy-plane
BX, BY, BZ = np.vectorize(brtot_cartesian)(i, a, 0, Y, Z)

# Calculate the magnetic field magnitude
B_mag = np.sqrt(BX**2 + BY**2 + BZ**2)

# Create 2D plot for the density map in the zy-plane
fig, ax = plt.subplots(figsize=(8, 6))

# Plot the density map for the magnetic field magnitude
c = ax.pcolormesh(Y, Z, B_mag, cmap='viridis', shading='auto')
fig.colorbar(c, ax=ax, label='Magnetic Field Strength (T)')
strm = ax.streamplot(Y, Z, BY, BZ, color=np.sqrt(BX**2 + BY**2), linewidth=1, cmap='viridis')
# Add labels and title
ax.set_xlabel('Y (mm)')
ax.set_ylabel('Z (mm)')
ax.set_title('Magnetic Field Density Map in the ZY Plane')

plt.show()
